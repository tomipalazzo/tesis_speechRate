#%% #import tables_speechRate as my_tables

#%% TODO 
# 1. Identify the silence and call it 'sil' - OK
# 1.1 Do the necesary changes - OK
# 2. Do the Pablo's features - OK
# 3 Split train and test correctly


import sys
#from charsiu.src import models
from charsiu.src.Charsiu import Wav2Vec2ForFrameClassification, CharsiuPreprocessor_en, charsiu_forced_aligner
import torch 
import numpy as np
import matplotlib.pyplot as plt
import IPython.display as ipd
from datasets import load_dataset
import pandas as pd
import random
import librosa
#import src.tables_speechRate as my_tables
import src.utils as ut
import time
from sklearn import linear_model
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
import seaborn as sns
import ast  # For safely evaluating strings containing Python literals

# ---------------------------- LOAD DATASET -----------------------------------
#%% Load TIMIT
TIMIT = load_dataset('timit_asr', data_dir='/home/tomi/Documents/tesis_speechRate/timit')
TIMIT_train = TIMIT['train']
TIMIT_test = TIMIT['test']

#%% Load the Dataframes in the correct directory


record_phone_test = pd.read_csv('../tesis_speechRate/TIMIT_df_by_record_phone_test.csv')
record_phone_train = pd.read_csv('../tesis_speechRate/TIMIT_df_by_record_phone_train.csv')
sample_phone_train = pd.read_csv('../tesis_speechRate/TIMIT_df_by_sample_train.csv')
sample_phone_test = pd.read_csv('../tesis_speechRate/TIMIT_df_by_sample_test.csv')


#%% Load any CHARSIU phonogram generated by Get phonograms
#SAMPLE_ID = SAMPLE_IDs_TEST[0]
#phonogram = pd.read_csv('../tesis_speechRate/data_phonograms/CHARSIU/Test/'+SAMPLE_ID+'.csv')
#phonogram = phonogram.to_numpy()
#%% ---------------------------------------------------------------------------



# %% -------------------- FORCED ALIGNMENT -----------------------------------


# Line 1: Instantiate a forced aligner object from the 'charsiu' library using a specified model.
# 'aligner' specifies the model to be used for alignment, likely based on the Wav2Vec 2.0 model trained for frame classification every 10 milliseconds.
charsiu = charsiu_forced_aligner(aligner='charsiu/en_w2v2_fc_10ms')

# Line 2: Load a pre-trained model from Hugging Face's 'transformers' library.
# This model is likely a fine-tuned version of Wav2Vec 2.0 for the task of frame classification, useful for tasks like forced alignment or phoneme recognition.
modelo = Wav2Vec2ForFrameClassification.from_pretrained("charsiu/en_w2v2_fc_10ms")

# Line 3: Set the model to evaluation mode. This disables training specific behaviors like dropout, 
# ensuring the model's inference behavior is consistent and deterministic.
modelo.eval()

# Line 4: Instantiate a preprocessor for English from the 'charsiu' library.
# This object is likely used to prepare audio data by normalizing or applying necessary transformations 
# before it can be inputted to the model.
procesador = CharsiuPreprocessor_en()
#%%
phonemes_index = np.arange(0,42)
phonemes = [charsiu.charsiu_processor.mapping_id2phone(int(i)) for i in phonemes_index]
print(phonemes)

#%%
# Example: Forced alignment of an audio file

# Audio by my own: 
audio_file = '../tesis_speechRate/audios_tomas/she_has_your.wav'  # Replace with the path to your audio file
waveform, sample_rate = librosa.load(audio_file, sr=None)
# Play audio


x = torch.tensor(np.array([waveform]).astype(np.float32))
with torch.no_grad():
    y = modelo(x)
    y = modelo(x).logits
    y_softmax = torch.softmax(y, dim=2)

y = y.numpy()[0].T
y_softmax = y_softmax.numpy()[0].T

#y_softmax[0,:] = 1
plt.figure(figsize=(10, 7))
plt.pcolor(y_softmax)
plt.yticks(np.arange(0.5, 42.5, 1), phonemes)
plt.title('Phonogram')
plt.colorbar()
plt.show()


# ----------------------------------------------------------------------------

#%% With softmax
plt.figure(figsize=(10, 7))
plt.pcolor(y_softmax)
plt.yticks(np.arange(0.5, 42.5, 1), phonemes)
plt.title('Phonogram')
plt.colorbar()
plt.show()


#%% --------------------- FUNCTIONS ------------------------------------------
def get_phonograms(TIMIT_set, model, n_samples = 10,  train=True):
    t0 = time.time()
    phonograms = []
    

    print('--------------GETTING PHONOGRAMS-----------------')
    for i in range(n_samples):
        sample = TIMIT_set[i]

        sample_id = get_sample_ID(sample['dialect_region'], sample['speaker_id'], sample['id'])
        
        audio_data = sample['audio']['array']
        x = torch.tensor(np.array([audio_data]).astype(np.float32))
        with torch.no_grad():
            y = model(x).logits
        y = y.numpy()[0].T

        # Save each phonogram as a matrix the ohonograms are numpy.ndarray
        y_df = pd.DataFrame(y)
        if train:
            y_df.to_csv('../tesis_speechRate/src/processing/data_phonograms/CHARSIU/Train/' + sample_id + '.csv', index=False)
        else:
            y_df.to_csv('../tesis_speechRate/src/processing/data_phonograms/CHARSIU/Test/' + sample_id + '.csv', index=False)
        
        
       # phonograms.append([sample_id,y]) 
        if i % 10 == 0:

            print('SAMPLE ', i, ' OF ', n_samples)

    t1 = time.time()
    print('-------------------------------------------------')
    print('Time to get phonograms: ', t1-t0)

# Dataframes with the array of the samples (array_id, array)

def get_sample_ID(dialect_region, speaker_id, id):
    return dialect_region + '_' + speaker_id + '_' + id

def get_sample_IDs(TIMIT_set, n_samples = 10):
    sample_id = []
    for i in range(n_samples):
        sample = TIMIT_set[i]
        sample_id.append(get_sample_ID(sample['dialect_region'], sample['speaker_id'], sample['id']))
    return sample_id

def get_dialectRegion_and_speacker_ID(sample_ID):
    # Sample_ID is an string, for example: 'DR1_CJF0_SA1'
    # Until the first '_' is Dialect region
    # Until the second '_' is the speaker ID
    parts = sample_ID.split('_')
    DR_ID = parts[0]
    speaker_ID = parts[1]
    return DR_ID, speaker_ID

#  Phonogram features
def phonogram_to_features(sample_ID, train=True):
    if train:
        phonogram = pd.read_csv('../tesis_speechRate/src/processing/data_phonograms/CHARSIU/Train/'+sample_ID+'.csv')
    else: 
        phonogram = pd.read_csv('../tesis_speechRate/src/processing/data_phonograms/CHARSIU/Test/'+sample_ID+'.csv')
    
    phonogram = phonogram.to_numpy()
    delta = librosa.feature.delta(phonogram)
    d_delta = librosa.feature.delta(phonogram, order=2)
    
    DR_ID, speaker_ID = get_dialectRegion_and_speacker_ID(sample_ID=sample_ID)

    dic = {'sample_id': sample_ID}
    dic['region_id'] =  DR_ID
    dic['speaker_id'] = speaker_ID
    
    # TODO: Vectorizar al estilo numpy

    # Mean each phonogram
    means = np.mean(phonogram, axis=1)
    mean_dic = {f'mean_phone_{i+1}': mean for i, mean in enumerate(means)}
    dic.update(mean_dic)

    # STD each phonogram
    stds = np.std(phonogram, axis=1)
    std_dic = {f'std_phone_{i+1}': std for i, std in enumerate(stds)}
    dic.update(std_dic)
    
    # STD delta each phonogram
    mean_delta = np.mean(delta, axis=1)
    mean_delta_dic = {f'mean_delta_phone_{i+1}': mean for i, mean in enumerate(mean_delta)}
    dic.update(mean_delta_dic)

    # STD delta each phonogram
    std_delta = np.std(delta, axis=1)
    std_delta_dic = {f'std_delta_phone_{i+1}': std for i, std in enumerate(std_delta)}
    dic.update(std_delta_dic)

    # STD delta each phonogram
    mean_d_delta = np.mean(d_delta, axis=1)
    mean_d_delta_dic = {f'mean_d_delta_phone_{i+1}': mean for i, mean in enumerate(mean_d_delta)}
    dic.update(mean_d_delta_dic)

    # STD delta each phonogram
    std_d_delta = np.std(d_delta, axis=1)
    std_d_delta_dic = {f'std_d_delta_phone_{i+1}': std for i, std in enumerate(std_d_delta)}
    dic.update(std_d_delta_dic)

    # Mean absolute value of each phonogram
    abs_mean_phonogram = np.mean(np.abs(phonogram), axis=1)
    abs_mean_phonogram_dic = {f'mean_abs_phone_{i+1}': mean for i, mean in enumerate(abs_mean_phonogram)}
    dic.update(abs_mean_phonogram_dic)

    # Mean absolute value of each delta
    mean_abs_delta = np.mean(np.abs(delta), axis=1)
    mean_abs_delta_dic = {f'mean_abs_delta_phone_{i+1}': mean for i, mean in enumerate(mean_abs_delta)}
    dic.update(mean_abs_delta_dic)

    # Mean absolute value of each delta
    mean_abs_d_delta = np.mean(np.abs(d_delta), axis=1)
    mean_abs_d_delta_dic = {f'mean_abs_d_delta_phone_{i+1}': mean for i, mean in enumerate(mean_abs_d_delta)}
    dic.update(mean_abs_d_delta_dic)

    # Add the feature of softmax
    feature_softmax = how_many_probables_phones(phonogram)[0]
    dic_feature_softmax = {f'feature_softmax_{i+1}': feature for i, feature in enumerate(feature_softmax)}
    dic.update(dic_feature_softmax)

    # Add the mean feature of softmax
    mean_feature_softmax = how_many_probables_phones(phonogram)[1]
    dic_mean_feature_softmax = {f'mean_feature_softmax_{i+1}': feature for i, feature in enumerate(mean_feature_softmax)}
    dic.update(dic_mean_feature_softmax)    


    # Means realated of all the phonogram
    dic['all_mean_phonogram'] = np.mean(phonogram)
    dic['all_mean_delta'] = np.mean(delta)
    dic['all_mean_d_delta'] = np.mean(d_delta)
    dic['all_std_phonogram'] = np.std(phonogram)
    dic['all_mean_abs_phonogram'] = np.mean(np.abs(phonogram))
    dic['all_mean_abs_delta'] = np.mean(np.abs(delta))
    dic['all_mean_abs_d_delta'] = np.mean(np.abs(d_delta))
    
    dic['greedy_feature'] = greedy_feature(phonogram)[0]
    
    
    features = pd.DataFrame(dic, index=[0])
    # Save the features as a csv file
    return features

def phonograms_to_features(sample_IDs, train = True):
    print('==============GETTING PHONOGRAMS FEATURES================')
    features = pd.DataFrame()
    for i in range(len(sample_IDs)):
        features = pd.concat([features, phonogram_to_features(sample_IDs[i], train=train)], ignore_index=True)

        if i % 10 == 0:
            print('SAMPLE ', i, ' OF ', len(sample_IDs))
            print('-------------------------------------------------')
    #save features
    if train:
        features.to_csv('../tesis_speechRate/src/processing/data_phonograms/data_features/Train/features_train.csv', index=False)
    else:
        features.to_csv('../tesis_speechRate/src/processing/data_phonograms/data_features/Test/features_test.csv', index=False)

    print('=================FINISHED===================')        
    return features

def softmax_phonogram(phonogram):
    # dataframe to torch
    phonogram = torch.tensor(phonogram.astype(np.float32))
    phonogram_softmax = torch.softmax(phonogram, dim=0)
    #to numpy
    phonogram_softmax = phonogram_softmax.numpy()

    return phonogram_softmax

def greedy_feature(phonogram, t=0):
    T = phonogram.shape[1]
    
    if t == 0:
        t = T

    s = np.zeros(t)
    how_many_until_i = 0

    argmax = -1
    for i in range(t):
        arg_max_new = np.argmax(phonogram[:,i])
        is_a_silence = arg_max_new == 0
        is_a_new_phone = arg_max_new != argmax 

        if (is_a_new_phone) and (not is_a_silence):
            argmax = arg_max_new
            how_many_until_i += 1
        s[i] = how_many_until_i
    
    mean_most_probable_phones = how_many_until_i/t

    return mean_most_probable_phones,s
        
#def mean_phones_features(phonogram):
#    how_many_phones_argMax = how_many_phones_since_t(phonogram)[0]
#    how_many_probables_phone = how_many_probables_phones(phonogram)[0]
#    T = phonogram.shape[1]/100 # 100 is the number of frames per second
#    return how_many_phones_argMax/T, how_many_probables_phone/T

def how_many_probables_phones(phonogram, t=0):
    number_of_phones = 42
    T = phonogram.shape[1]
    if t == 0:
        t = T
    phonogram_softmax = softmax_phonogram(phonogram)
    phonogram_softmax = phonogram_softmax > 0.5
    
    d_phonogram_softmax = np.diff(phonogram_softmax, axis=1)

    res  = np.zeros(number_of_phones)
    for i in range(number_of_phones):
        res[i] = np.sum(d_phonogram_softmax[i,:])

    

    return res, res/t




#%% -------------------------- GENERATE PHONOGRAMS -----------------------------
# OBS: This process takes a long time. It save the phonograms as csv files in the data_phonograms folder 


N_TRAIN = len(TIMIT_train)
N_TEST = len(TIMIT_test)

#get_phonograms(TIMIT_train, modelo, 10, train=True)



# =======Get phonograms TEST============= UNCOMMENT TO GET PHONOGRAMS

#get_phonograms(TIMIT_test, modelo, N_TEST, train=False)


#%% ---------------------------- GLOBAL VARIABLES --------------------------------

SAMPLE_IDs_TRAIN = get_sample_IDs(TIMIT_train, N_TRAIN)
SAMPLE_IDs_TEST = get_sample_IDs(TIMIT_test, N_TEST)


# ------------------------------- TEST FUNCTIONS --------------------------------------
#%% Test the functions
SAMPLE_ID = SAMPLE_IDs_TRAIN[0]
# read the phonogram
phonogram = pd.read_csv('../tesis_speechRate/src/processing/data_phonograms/CHARSIU/Train/'+SAMPLE_ID+'.csv')

plt.figure(figsize=(10, 7))
plt.pcolor(phonogram)
plt.yticks(np.arange(0.5, 42.5, 1), phonemes)
plt.title('Phonogram')
plt.colorbar()
plt.show()

phonogram = phonogram.to_numpy()
phonogram_softmax = softmax_phonogram(phonogram)
phonogram_softmax = phonogram_softmax > 0.5
plt.figure(figsize=(10, 7))
plt.pcolor(phonogram_softmax)
plt.yticks(np.arange(0.5, 42.5, 1), phonemes)
plt.colorbar()
plt.title('Phonogram')

#%%

#how_many_phones_since_t(phonogram)
#print(how_many_phones_since_t(phonogram)[1])
#mean_phones_arg_max(phonogram)
how_many_probables_phones(phonogram)[0]

#%% -------------------------- GENERATE FEATURES -----------------------------

# Get phonogram features of N_SAMPLES samples in the training set

phonogram_features_TRAIN = phonograms_to_features(SAMPLE_IDs_TRAIN, train = True)
phonogram_features_TEST = phonograms_to_features(SAMPLE_IDs_TEST, train = False)

# READ FEATURES 
phonogram_features_TRAIN = pd.read_csv('../tesis_speechRate/src/processing/data_phonograms/data_features/Train/features_train.csv')
phonogram_features_TEST = pd.read_csv('../tesis_speechRate/src/processing/data_phonograms/data_features/Test/features_test.csv')

#%%
phonogram_features_TRAIN.set_index('sample_id', inplace=True)
phonogram_features_TEST.set_index('sample_id', inplace=True)


# Merge the phonogram features with the sample_phone dataframes
sample_phone_train.set_index('sample_id', inplace=True)
sample_phone_test.set_index('sample_id', inplace=True)
#%%
df_X_TRAIN = pd.merge(phonogram_features_TRAIN, sample_phone_train, left_index=True, right_index=True)
#%% -------------------------- SPLITTING -------------------------------------
speaker_id = df_X_TRAIN['speaker_id'].unique()
n_speakers = len(speaker_id)

# 80% Train - 20% Val
n_train = round(0.8*n_speakers)
n_val = n_speakers - n_train
# Choose randomly
random.shuffle(speaker_id)
speaker_id_train = speaker_id[:n_train]
speaker_id_val = speaker_id[n_train:]
#%%
# Filter the speaker_id_train
df_TRAIN = df_X_TRAIN[df_X_TRAIN['speaker_id'].isin(speaker_id_train)]
df_VAL = df_X_TRAIN[df_X_TRAIN['speaker_id'].isin(speaker_id_val)]


# %% TRAIN SET
X_TRAIN  = df_TRAIN.drop(columns=['region_id', 'speaker_id', 'mean_speed_wpau_m1', 'mean_speed_wpau_m2', 'mean_speed_wopau_m1', 'mean_speed_wopau_m2'])
y_TRAIN = df_TRAIN['mean_speed_wpau_m1']
X_VAL = df_VAL.drop(columns=['region_id', 'speaker_id', 'mean_speed_wpau_m1', 'mean_speed_wpau_m2', 'mean_speed_wopau_m1', 'mean_speed_wopau_m2'])
y_VAL = df_VAL['mean_speed_wpau_m1']
# %% =================== FEATURES SELECTION ===================================

A = ['all_mean_phonogram', 
     'all_mean_delta', 
     'all_mean_d_delta', 
     'all_std_phonogram',
     'all_mean_abs_phonogram',
     'all_mean_abs_delta',
     'all_mean_abs_d_delta'] 



#%% ALl PHONES FEATURES
B = []
B_mean = ['mean_phone_' + str(i) for i in range(2, 40)]
B_std = ['std_phone_' + str(i) for i in range(2, 40)]
B_mean_delta = ['mean_delta_phone_' + str(i) for i in range(2, 40)]
B_std_delta = ['std_delta_phone_' + str(i) for i in range(2, 40)]   
B_mean_d_delta = ['mean_d_delta_phone_' + str(i) for i in range(2, 40)]
B_std_d_delta = ['std_d_delta_phone_' + str(i) for i in range(2, 40)]
B_abs = ['mean_abs_phone_' + str(i) for i in range(2, 40)]
B_abs_delta = ['mean_abs_delta_phone_' + str(i) for i in range(2, 40)]
B_abs_d_delta = ['mean_abs_d_delta_phone_' + str(i) for i in range(2, 40)]
B_softmax = ['feature_softmax_' + str(i) for i in range(2, 40)]
B_mean_softmax = ['mean_feature_softmax_' + str(i) for i in range(2, 40)]



B = B_mean + B_std + B_mean_delta + B_std_delta + B_mean_d_delta + B_std_d_delta + B_abs + B_abs_delta + B_abs_d_delta + B_softmax + B_mean_softmax

C = B_mean_softmax

D = ['greedy_feature']

#%% NEW FEATURES
#G = ['mean_how_many_phones_arFgMax']
#H = ['mean_how_many_probables_phones']

mean_phone = df_TRAIN.filter(regex='^mean_phone_*')
#%% Metric 1
y_TRAIN = df_TRAIN['mean_speed_wpau_m1']
y_VAL = df_VAL['mean_speed_wpau_m1']

features = [A,F, G, H]
MSE_features_wpau = np.zeros(len(features))
scores_wpau = np.zeros(len(features))
for j in range(10):
    for i in range(len(features)):
        print('Features:', features[i])
        X_TRAIN_fi = X_TRAIN[features[i]]
        X_VAL_fi = X_VAL[features[i]]
        
        # Regression
        positive=True
        model = linear_model.LinearRegression(positive=positive)
        model.fit(X_TRAIN_fi, y_TRAIN)
        y_pred = model.predict(X_VAL_fi)
        MSE_features_wpau[i] += mean_squared_error(y_VAL, y_pred)
        scores_wpau[i] += model.score(X_VAL_fi, y_VAL)

mean_score_features_wpau = scores_wpau/10
mean_MSE_features_wpau = MSE_features_wpau/10

#%% Metric 2
y_TRAIN = df_TRAIN['mean_speed_wpau_m2']
y_VAL = df_VAL['mean_speed_wpau_m2']
MSE_features_wopau = np.zeros(len(features))
scores_wopau = np.zeros(len(features))
for j in range(10):
    for i in range(len(features)):
        print('Features:', features[i])
        X_TRAIN_fi = X_TRAIN[features[i]]
        X_VAL_fi = X_VAL[features[i]]
        
        # Regression
        positive=True
        model = linear_model.LinearRegression(positive=positive)
        model.fit(X_TRAIN_fi, y_TRAIN)
        y_pred = model.predict(X_VAL_fi)
        MSE_features_wopau[i] += mean_squared_error(y_VAL, y_pred)
        scores_wopau[i] += model.score(X_VAL_fi, y_VAL)

mean_score_features_wopau = scores_wopau/10
mean_MSE_features_wopau = MSE_features_wopau/10


#%%
# Do barplot of the features with MSE add one next to the other
x = np.arange(len(features))
width = 0.35  # the width of the bars
fig, ax = plt.subplots()
rects1 = ax.bar(x - width/2, mean_score_features_wpau, width, label='With pauses M1')
rects2 = ax.bar(x + width/2, mean_score_features_wopau, width, label='With pauses M2')
plt.xticks(np.arange(len(features)), ['A, dim:' + str(len(A)),'B, dim:'+ str(len(F)),'C, dim:'+ str(len(G)), 'D, dim:'+ str(len(H))]
           , rotation=70)

# Add in this plot the name of each feature
plt.title('Prediction of the speech rate')
plt.xlabel('Groups of features')
plt.ylabel('Mean R2 - 50 iterations')
plt.legend()
plt.show()


# %% Correlation Matrix

ALL_FEATURES = F
X_TRAIN_ALL = X_TRAIN[ALL_FEATURES]
sns.heatmap(X_TRAIN_ALL.corr())
plt.title('Correlation Matrix of the features')




# %% 
sns.heatmap(mean_phone.corr())
# %%


X_TRAIN
# %% 
sns.pairplot(pd.concat([X_TRAIN.filtermean_speed_wopau(regex='all_*'),y_TRAIN],axis=1), hue="mean_speed_wopau", palette="husl")


# %%
# %%
# PCA
from sklearn.decomposition import PCA
pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_TRAIN[ALL_FEATURES])
plt.scatter(X_pca[:,0], X_pca[:,1], c=y_TRAIN)
plt.colorbar()
#score
pca.score(X_VAL[ALL_FEATURES], y_VAL)

# %%
